import { BorderedImage } from '../../page/figure/bordered-image/bordered-image';
import { TimelineElementParameters } from '../../page/timeline-element/timeline-element-parameters';
import processSimulatorPoster from '../media/process-simulator.jpg';

export const nuclear: TimelineElementParameters = {
  title: 'Simulating the cooling system of a nuclear facility',
  date: '2018 October - November',
  figure: new BorderedImage({
    image: processSimulatorPoster,
    alt: 'a screenshot of the simulator',
  }),
  description:
    'The temperatures and flow volumes are dynamically calculated by two graph models on a remote server while multiple "monitoring" clients update in real-time.',
  more: [
    'The simulated system is easily extensible and, by default, can contain reactors (heaters), coolers, pumps, heat exchangers, drains, sources, and of course, pipes. With these, simple yet believable configurations can be dynamically defined.',

    'My project aimed to create a cheaply calculated and, for the average person, convincing simulation which is simply scalable and has a clean GUI. The algorithm takes advantage of graphs and matrices to get to update the state iteratively.',

    'First, water is distributed by traversing the graph of pipes and according to the pressures generated by the pumps. Then, an adjacency matrix is populated with the relations of the nodes (based on the water flow between them). After considering the base temperatures, heaters, and heat exchangers, the matrix is solved, resulting in the current temperature of each node. This can be repeated many times, and coming from the operations semantic, time-travel is also straightforward to implement.',

    'Python is used for the backend, along with Flask and NumPy. A REST API facilitates communication between the layers. For rendering the front end, an HTML5 canvas is utilised.',
  ],
  links: [],
};
